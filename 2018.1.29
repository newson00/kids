上午，正则表达式的应用，效率好慢，最近头脑有点晕，思维不是很清晰，最大的特点就是晕；
下午，正则：.匹配换行符的任意字符串，比如经典的  .*
\w 字母、数字、下划线或汉字； \s任意的空白字符； \d匹配数字；\b单词的开始或结束，比较特别，不比较别的东西；
^字符串开始 ； $字符串结束；
^\d{5,12}$ 5位到12位之间；

哦，上面的叫元字符，下面的叫限定符，也就是几个的意思：
* 重复0次或更多次； + 至少重复1次； ？最多重复1次；  {n}重复n次；  {n，}至少n次；   {n，m}重复n到m次；

字符类： [aeiou]匹配任何一个其中的字母； [.?!]匹配标点符号；同理[0-9]表达和\d是一个意思，一位数字；
同理的[a-z0-9A-Z]完全等同于 \w，有数字、字母，还少个下划线；
中括号[]是里面的任意一个，大括号是{}限定多少的

举一个列子：\(?0\d{2}[)-]?\d{8} 分析：\(?，有或者是没有(, 0开头的，\d{2}2 2位数字的，  [)-]? ）或者是- 有
或者是没有的，  \d{8} 表示后面有8位数字。    符合的有 (010)88886666   022-22334455  02912345678  ；其中前面有
（ 后面有-  是个例外；那么为了解决这个问题，就要用到分支条件，

乖乖，4点27了，看来脑子晕晕乎乎的，效率真是低下啊！
分支条件：就是| java里面就是 || 的意思，比如 ： 0\d{2}-\d{8}|0\d{3}-\d{7} 再比如： \(0\d{2}\)[-]?\d{8}|0\d{2}[-]?\d{8}
还有个重点，匹配时从左向右，如果\d{5}-\d{4}|\d{5}，就可以匹配5位或者是9位数字，如果反过来，\d{5}|\d{5}-\d{4}，那么当9位数字进来后
只匹配前五位，满足了，后面就不管了，正则是孔，外卖的是料，孔小了，出来的料都一样；

分组，又一个好东西啊，重复好几个单个数字好弄，那要是重复123呢，比如(\d{1,3}\.){3}\d{1,3} 其中(\d{1,3}\.){3} 3个数字加个.
重复3次,这个叫分组；但是ip地址不能随便来，表达式又不能计算，就只能分组来写了：
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[01]|[01]?\d\d?) 关键是2[0-4]\d|25[0-5]|[01]?\d\d? 每个数字不能
大于255,01这种也行的；


反义，
  有些时候，规定的太多，要找反义词，这就要用到反义了，
  \W 不是字母，数字，下划线，汉字的字符
  \S 不是空白符的字符
  \D 任意非数字的字符
  \B 不是单词开头或者结束的位置
  [^x] 匹配除了x以外的任意字符
  [^ aeiou] 除了aeiou以外的任意字符
    那么\S+就是不包含空白字符的字符串；<a[^>]+>用尖括号括起来的以a开头的字符串（里面只有1对<>）
    
    
如果，我们要找到一个像 go go ，hello hello这样的东西，也可以用正则来表达：
\b(\w+)\b\s+\1\b 理解：首先是一个单词： \b(\w+)\b 被匹配到的单词被放在分组1中，
然后是一个或多个空白字符\s+，然后是分组1：\1中捕获的内容，就是重复一次刚才的（\w+）,\b单词结束
还可以修改刚才的组名（？<word>\w+）换成（？‘word’\w+）也行，就把分组名换成word，
如果要反向引用，可以\k<word> 所以，刚才的例子可以写成 \b(?<word>\w+)\b\s+\k<word>\b
小括号还有多种特定的用法，例如：
捕获： （exp）捕获文本到组里（？<name>exp）捕获文本到name组里， （？:exp）不捕获，也不分组
零宽断言： （？=exp）匹配exp前面的位置 （？<=exp）exp后面的位置 （？！exp）匹配后面跟的不是exp的位置（？<!exp）前面不是exp的位置
注释： （？# comment）工人阅读的

再比如，如果我们要找到一句话中，ing结尾的，怎么办:看好了，\b\w+(?=ing\b)，那么下面一句话：
i'm singing while you're dancing 那么就会找到sing和danc；如果是开头，比如 reading a book
（？<=\bre）\w+\b 那么 就会整回来一个ading ;看到没，括号里面的都没匹配上；
这一块 还是可以加工的；
要是不想匹配到某些东西的话： \b\w*q[^u]\w*\b,包含后面不是字母u的字母q的单词；但是呢，在比如iraq上就会出错，
因为[^u]总要匹配到1个字符，如果匹配了单词的分隔符啥的，那后面的\w就会怼到下一个单词，就出错了；
但是如果是负向零宽断言，因为它只匹配一个位置，不消费任何字符，可以这么写\b\w*q(?!u)\w+\b
断言的后面不能匹配表达式，\d{3}(?!\d)3位数字，后面不能是数字，\b((?!abc)\w)+\b  这就是不包含
abc的 单词，单词长度大于1，因为（？！abc）占用了一个字母位置；再来个例子：（？<![a-z]）\d{7}前面不是
小写字母的7位数字；
来个复杂点的试试：

插一句， 断言是声明一个应该为真的事实，只有为真的时候才能用，只是判断，这点很重要
有的是零宽度，先行是后面出现的是否符合（？=exp），后发是
前面是否符合（？<=exp）， 没有的负向零宽度 ，先行是后面没有（？！exp），后发是（？<！exp）；
虽然是个声明，但是不站前面或者后面的东西；

不包含属性的简单html标签里面的内容 （?<=<(\w+)>）.* (?=<\/\1>)










  










